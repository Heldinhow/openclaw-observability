# Data Model: Real-time Logs Viewer

**Feature**: 002-realtime-logs-tab  
**Date**: 2026-02-06  
**Source**: Feature specification and research findings

---

## Entity: LogEntry

Represents a single log event from OpenClaw gateway.

### Attributes

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `id` | string | Yes | Unique identifier (UUID v4) generated by backend for deduplication |
| `timestamp` | ISO 8601 string | Yes | When the log was generated (original timestamp from OpenClaw) |
| `level` | enum | Yes | Log severity: `trace`, `debug`, `info`, `warn`, `error`, `fatal` |
| `subsystem` | string | Yes | Component that generated the log (e.g., "gateway", "channels/whatsapp") |
| `message` | string | Yes | Main log message content |
| `metadata` | object | No | Additional structured data (varies by subsystem) |
| `correlationId` | string | No | Request trace ID for distributed tracing |
| `sourceFile` | string | No | Original log file path (for debugging) |
| `parsedAt` | ISO 8601 string | Yes | When the backend parsed this entry |

### Validation Rules

- `timestamp` must be valid ISO 8601 date-time
- `level` must be one of the defined enum values
- `subsystem` must be non-empty string, max 100 chars
- `message` must be non-empty string, max 10000 chars (truncated if longer)
- `metadata` must be serializable object (no circular references)
- `correlationId` must be alphanumeric with dashes, max 64 chars

### Example

```json
{
  "id": "550e8400-e29b-41d4-a716-446655440000",
  "timestamp": "2026-02-06T14:30:00.123Z",
  "level": "info",
  "subsystem": "gateway/channels/whatsapp",
  "message": "Webhook received from WhatsApp",
  "metadata": {
    "webhookId": "msg_12345",
    "chatId": "5511999999999@c.us",
    "messageType": "text"
  },
  "correlationId": "req-abc-123",
  "sourceFile": "/tmp/openclaw/openclaw-2026-02-06.log",
  "parsedAt": "2026-02-06T14:30:00.500Z"
}
```

---

## Entity: LogStream

Represents the real-time streaming connection state.

### Attributes

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `clientId` | string | Yes | Unique identifier for the SSE connection |
| `connectedAt` | ISO 8601 string | Yes | When the connection was established |
| `filter` | LogFilter | No | Active filter configuration for this stream |
| `status` | enum | Yes | Connection state: `active`, `paused`, `error`, `closed` |
| `lastEventId` | string | No | SSE Last-Event-ID for reconnection support |
| `entriesDelivered` | number | Yes | Count of log entries sent through this stream |

### State Transitions

```
active --> paused  (user clicks pause)
active --> error   (log source unreachable)
active --> closed  (user disconnects)
paused --> active  (user clicks resume)
paused --> closed  (user disconnects)
error  --> active  (auto-retry successful)
error  --> closed  (user disconnects)
```

---

## Entity: LogFilter

Represents user-selected filtering criteria.

### Attributes

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `levels` | enum[] | No | Array of levels to include (empty = all levels) |
| `searchText` | string | No | Text to search in message and metadata |
| `subsystem` | string | No | Filter by specific subsystem (supports wildcards) |
| `timeRange` | object | No | Start and end timestamps for time-based filtering |
| `timeRange.start` | ISO 8601 string | No | Include logs from this time |
| `timeRange.end` | ISO 8601 string | No | Include logs up to this time |

### Validation Rules

- `levels` array items must be valid log levels
- `searchText` max 500 characters
- `subsystem` max 100 characters, supports `*` wildcard
- `timeRange.start` must be <= `timeRange.end`
- All filters are optional and combined with AND logic

### Example

```json
{
  "levels": ["error", "warn"],
  "searchText": "webhook",
  "subsystem": "gateway/*",
  "timeRange": {
    "start": "2026-02-06T10:00:00Z",
    "end": "2026-02-06T15:00:00Z"
  }
}
```

---

## Entity: LogBatch

Represents a paginated collection of log entries for "Load More" functionality.

### Attributes

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `entries` | LogEntry[] | Yes | Array of log entries |
| `pagination` | object | Yes | Pagination metadata |
| `pagination.cursor` | string | Yes | Opaque cursor for next page |
| `pagination.hasMore` | boolean | Yes | Whether more entries exist |
| `pagination.total` | number | No | Total count of matching entries (if available) |

### Example

```json
{
  "entries": [...],
  "pagination": {
    "cursor": "eyJ0aW1lc3RhbXAiOiIyMDI2LTAyLTA2VDE0OjMwOjAwLjEyM1oifQ==",
    "hasMore": true,
    "total": 15000
  }
}
```

---

## Entity: StreamStatus

Represents the current status of the log streaming system.

### Attributes

| Field | Type | Required | Description |
|-------|------|----------|-------------|
| `isConnected` | boolean | Yes | Whether connected to log source |
| `isPaused` | boolean | Yes | Whether stream is paused by user |
| `lastError` | string | No | Most recent error message (if any) |
| `lastErrorAt` | ISO 8601 string | No | When the last error occurred |
| `entriesInMemory` | number | Yes | Current count of entries in client memory |
| `entriesTotal` | number | No | Total entries available on server |
| `nextRetryAt` | ISO 8601 string | No | When next auto-retry will occur |

### Example

```json
{
  "isConnected": true,
  "isPaused": false,
  "lastError": null,
  "lastErrorAt": null,
  "entriesInMemory": 250,
  "entriesTotal": 15420,
  "nextRetryAt": null
}
```

---

## Relationships

```
┌─────────────┐     has one      ┌─────────────┐
│  LogStream  │◄────────────────►│  LogFilter  │
└──────┬──────┘                  └─────────────┘
       │
       │ delivers
       ▼
┌─────────────┐     part of      ┌─────────────┐
│   LogEntry  │◄─────────────────│   LogBatch  │
└─────────────┘                  └─────────────┘
```

---

## Data Flow

### Real-time Streaming Flow

1. **OpenClaw** writes log to JSON Lines file
2. **LogStreamer** (backend) detects new line via `tail` library
3. **LogStreamer** parses JSON line into `LogEntry`
4. **LogStreamer** applies active `LogFilter` (if any)
5. **LogStreamer** broadcasts to all connected `LogStream` clients via SSE
6. **Frontend** receives SSE event, validates, adds to React state
7. **Frontend** enforces 250 entry memory limit (FIFO eviction)

### Historical Query Flow

1. **User** clicks "Load More" or applies filter
2. **Frontend** sends GET request with cursor/filter
3. **Backend** queries Redis cache (recent) or file system (older)
4. **Backend** returns `LogBatch` with entries and pagination
5. **Frontend** prepends older entries to existing list

### Filter Application Flow

1. **User** sets filter criteria (levels, search text, etc.)
2. **Frontend** validates `LogFilter` object
3. **Frontend** applies filter client-side to loaded entries
4. **Frontend** updates SSE connection with filter params
5. **Backend** applies filter before broadcasting new entries
6. **Backend** optionally queries historical data if filter changes

---

## Storage Strategy

### Redis Cache (Short-term)

- **Purpose**: Fast access to recent logs, reduce file I/O
- **Key Pattern**: `logs:recent:{YYYY-MM-DD}`
- **Data Structure**: Sorted Set (timestamp as score)
- **Retention**: 24 hours with LRU eviction
- **Max Entries**: 10,000 per day

### File System (Source of Truth)

- **Purpose**: Persistent log storage
- **Format**: JSON Lines (one JSON object per line)
- **Rotation**: Daily files (`openclaw-YYYY-MM-DD.log`)
- **Access**: Sequential read with `tail` for real-time, direct read for historical

### Client Memory (Transient)

- **Purpose**: Display and interaction
- **Limit**: 250 entries maximum
- **Eviction**: FIFO (oldest removed when limit exceeded)
- **Persistence**: None (reloaded from server on refresh)

---

## Indexing Strategy

For efficient filtering and search:

1. **By Timestamp**: Primary sort order (descending)
2. **By Level**: Secondary filter (indexed enum)
3. **By Subsystem**: String prefix matching with wildcards
4. **Full-text Search**: Simple substring match on `message` (no full-text index needed for MVP)

**Future Enhancement**: If log volume grows significantly, consider:
- Elasticsearch/OpenSearch for full-text search
- Time-series database (InfluxDB, TimescaleDB) for metrics
- Separate indexing service for complex queries

---

## Data Integrity

### Validation Layers

1. **Parse-time**: JSON schema validation for required fields
2. **Storage-time**: Type coercion and normalization
3. **Transmission-time**: Schema validation on API boundaries
4. **Display-time**: Sanitization for XSS prevention (escape HTML in messages)

### Error Handling

- **Invalid JSON line**: Log warning, skip entry, continue streaming
- **Missing required fields**: Use defaults or skip (configurable)
- **Encoding errors**: Replace invalid UTF-8 with replacement character
- **Oversized entry**: Truncate message to max length with `[truncated]` indicator

---

## Constraints & Limits

| Resource | Limit | Rationale |
|----------|-------|-----------|
| Client memory entries | 250 | Spec requirement, browser performance |
| Message max length | 10,000 chars | Prevent memory issues with huge logs |
| Search text max | 500 chars | Prevent abuse, sufficient for use cases |
| SSE connections | 100 per server | Resource protection |
| Filtered query timeout | 30 seconds | Prevent long-running queries |
| Historical query limit | 10,000 entries per request | Pagination enforcement |
